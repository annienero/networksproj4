#!/usr/bin/python -u

import sys
import socket
import Queue
from HTMLParser import HTMLParser

HOST = 'fring.ccs.neu.edu'
HTTP_VERSION = 'HTTP/1.1'
READ_SIZE = 8192

username = sys.argv[1]
password = sys.argv[2]
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, 80))

cookies = {}
visited = {}
toVisit = []
secretFlags = []
secretFlagInData = False
visitSize = 0


def resolveResponseHeaders(response):
    headerMap = {}
    tokenizedResponse = response.decode('utf-8').split('\r\n')
    for line in tokenizedResponse:
        if line == '\r\n':
            break
        try:
            colonIdx = line.index(':')
            headerMap[line[:colonIdx]] = line[colonIdx + 2:]
        except Exception as e:
            continue
    return headerMap


# updates our cookies dictionary with any cookies the given response told us to set
def parseResponseCookies(response):
    global cookies
    tokenizedResponse = response.decode('utf-8').split('\r\n')
    for line in tokenizedResponse:
        if line == '\r\n':
            break
        if 'Set-Cookie' in line:
            cookieInfo = line[12:]
            equalIdx = cookieInfo.index('=')
            semicolonIdx = cookieInfo.index(';')
            key = cookieInfo[:equalIdx]
            value = cookieInfo[equalIdx + 1:semicolonIdx]
            cookies[key] = value

def badResponse(response):
  tokens = response.split(" ")
  return tokens[1][0:1] == "4"
  print"------ got a 400 bad response:", response[:25]

# assumes that we've read up through the headers
def handleNormalBody(responseHeaders):
  global s
  print("---- HANDLING NORMAL BODY")
  return s.recv(int(responseHeaders['Content-Length']))
  
def handleChunkedBody(responseHeaders):
  global s
  print(" ---- HANDLING CHUNKED BODY")
  body = ""
  chunk = ""
  curLen = None
  while True:
    char = s.recv(1)
    chunk += char
    if char == "\n":
      print "about to read this chunk as hex length: ", chunk
      print "and the body so far is: ", body
      curLen = int(chunk[0:len(chunk)-2], 16)
      if curLen == 0:
        return body
      body += s.recv(curLen)
      chunk = "" # reset chunk
      #eat the extra newline
      eater = s.recv(2)


    

#returns the response gotten from sending the described HTTP request, and parses cookies from the response
def httpRequest(method, resource, headers, body):
    global s
    #build request
    request = method + ' ' + resource + ' ' + HTTP_VERSION + '\r\n'
    for key in headers:
        request += key + ': ' + headers[key] + '\r\n'
    request += 'Connection: keep-alive\r\n'
    request += 'Content-Length: ' + str(len(body.encode('utf-8'))) + '\r\n'
    request += 'Accept-Encoding: identity\r\n'
    request += 'Accept: text/html\r\n'
    request += 'Origin: http://' + HOST + '\r\n'
    request += 'Content-Type: application/x-www-form-urlencoded\r\n'
    if cookies:
        request += 'Cookie: ' + parseRequestDict(cookies, '; ') + '\r\n'
    request += '\r\n'
    request += body
    print "REQUEST", request
    # send request
    s.sendall(request.encode())
    # read response headers
    response = ""
    while True:
      chunk = s.recv(1)
      if not chunk:
        print(" -------------- CHUNK WAS EMPTY, SOMETHING HAS GONE HORRIBLY WRONG ---------------")
        #reopen connection
        s.close()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, 80))
        s.sendall(request.encode())
      response += chunk
      if "\r\n\r\n" in response:
        break
    responseHeaders = resolveResponseHeaders(response)
    print "------- RESPONSE SO FAR:", response

    if 'Transfer-Encoding' in responseHeaders and responseHeaders['Transfer-Encoding'] == 'chunked':
      response += handleChunkedBody(responseHeaders)
    elif 'Content-Length' in responseHeaders:
      response += handleNormalBody(responseHeaders)

    #done receiving response
    print "RESPONSE", response
    parseResponseCookies(response)
    responseMap = resolveResponseHeaders(response)
    if 'Connection' in responseMap and responseMap['Connection'] == 'close' and not badResponse(response):
        print(" ------------ RETRYING BECAUSE CONNECTION CLOSE OR SOME SHI ---------")
        s.close()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, 80))
        return httpRequest(method, resource, headers, body)
    print("mADE IT THROUGH ----- ----- - -- - --  ABOUT TO RETURN RESPONSE FROM HTTPREQUEST")
    return response

def parseRequestDict(dict, delim):
    str = ''
    for key in dict:
        str += key + '=' + dict[key] + delim
    return str[:len(str) - len(delim)]


# returns the response gotten from sending the login request to fakebook
def login():
    headers = {}
    headers['Host'] = HOST
    body = {}
    body['username'] = username
    body['password'] = password
    body['next'] = '%2Ffakebook%2F'
    body['csrfmiddlewaretoken'] = cookies['csrftoken']
    return httpRequest('POST', '/accounts/login/', headers, parseRequestDict(body, '&'))

# create a subclass and override the handler methods
class MyHTMLParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        global toVisit
        global secretFlagInData
        #if its a secret flags:
        secretFlagInData = (tag == 'h2' and ('class', 'secret_flag') in attrs)
        for attr in attrs:
            if tag == 'a' and attr[0] == 'href' and attr[1][:10] == '/fakebook/':
                if not (attr[1]) in visited:
                    toVisit.append(attr[1])
                    visited[attr[1]] = True

    def handle_endtag(self, tag):
        return

    def handle_data(self, data):
        global secretFlags
        if secretFlagInData:
            secretFlags.append(data[6:])

def main():
    global visited
    global toVisit
    global visitSize
    headers = {}
    headers['Host'] = HOST
    httpRequest('GET', '/accounts/login/', headers, '')
    loginResponse = login()
    loginHeaders = resolveResponseHeaders(loginResponse)
    print "LOGIN: ", loginResponse
    while 'Location' not in loginHeaders:
      loginResponse = login()
      loginHeaders = resolveResponseHeaders(loginResponse)
      print "TRY LOGIN AGAIN: ", loginResponse
    locationHeader = loginHeaders['Location']
    toVisit.append(locationHeader[locationHeader.index('/fakebook/'):])
    #toVisit.append("/")
    parser = MyHTMLParser()
    while len(toVisit) > 0:
        visitSize+=1
        curPage = toVisit.pop(0)
        response = httpRequest('GET', curPage, headers, '')
        try:
            firstTagIdx = response.index('<')
            htmlText = response[firstTagIdx:]
            parser.feed(htmlText)
        except Exception as e:
            pass
main()
for flag in secretFlags:
    print flag

req = """GET /fakebook/ HTTP/1.1
Host: fring.ccs.neu.edu
Connection: keep-alive
Content-Length: 0
Accept-Encoding: identity
Accept: text/html
Origin: http://fring.ccs.neu.edu
Content-Type: application/x-www-form-urlencoded
Cookie: csrftoken=8e749c0900959eca5b9ea9d6c9e2cc5f; sessionid=a39de56630922ee1b0e1cbccd733152f\r\n\r\n"""

#s.sendall(req.encode())
#resp = s.recv(READ_SIZE)
#print "RESPONSE", resp


s.close()
print("---- END OF PROGRAM ----")
