#!/usr/bin/python -u

import sys
import socket
import Queue
from HTMLParser import HTMLParser

HOST = 'fring.ccs.neu.edu'
HTTP_VERSION = 'HTTP/1.1'

username = sys.argv[1]
password = sys.argv[2]
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, 80))

cookies = {}
visited = {}
toVisit = []
secretFlags = []
secretFlagInData = False
visitSize = 0


def resolveResponseHeaders(response):
    headerMap = {}
    tokenizedResponse = response.decode('utf-8').split('\r\n')
    for line in tokenizedResponse:
        if line == '\r\n':
            break
        try:
            colonIdx = line.index(':')
            headerMap[line[:colonIdx]] = line[colonIdx + 2:]
        except Exception as e:
            continue
    return headerMap


# updates our cookies dictionary with any cookies the given response told us to set
def parseResponseCookies(response):
    global cookies
    tokenizedResponse = response.decode('utf-8').split('\r\n')
    for line in tokenizedResponse:
        if line == '\r\n':
            break
        if 'Set-Cookie' in line:
            cookieInfo = line[12:]
            equalIdx = cookieInfo.index('=')
            semicolonIdx = cookieInfo.index(';')
            key = cookieInfo[:equalIdx]
            value = cookieInfo[equalIdx + 1:semicolonIdx]
            cookies[key] = value

#returns the response gotten from sending the described HTTP request, and parses cookies from the response
def httpRequest(method, resource, headers, body):
    global s
    request = method + ' ' + resource + ' ' + HTTP_VERSION + '\r\n'
    for key in headers:
        request += key + ': ' + headers[key] + '\r\n'
    request += 'Connection: keep-alive\r\n'
    request += 'Content-Length: ' + str(len(body.encode('utf-8'))) + '\r\n'
    request += 'Origin: http://' + HOST + '\r\n'
    request += 'Content-Type: application/x-www-form-urlencoded\r\n'
    if cookies:
        request += 'Cookie: ' + parseRequestDict(cookies, '; ') + '\r\n'
    request += '\r\n'
    request += body
    s.sendall(request.encode())
    response = s.recv(4096)
    parseResponseCookies(response)
    responseMap = resolveResponseHeaders(response)
    if 'Connection' in responseMap and responseMap['Connection'] == 'close':
        s.close()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, 80))
    return response

def parseRequestDict(dict, delim):
    str = ''
    for key in dict:
        str += key + '=' + dict[key] + delim
    return str[:len(str) - len(delim)]


# returns the response gotten from sending the login request to fakebook
def login():
    headers = {}
    headers['Host'] = HOST
    body = {}
    body['username'] = username
    body['password'] = password
    body['next'] = '%2Ffakebook%2F'
    body['csrfmiddlewaretoken'] = cookies['csrftoken']
    return httpRequest('POST', '/accounts/login/', headers, parseRequestDict(body, '&'))

# create a subclass and override the handler methods
class MyHTMLParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        global toVisit
        global secretFlagInData
        #if its a secret flags:
        secretFlagInData = (tag == 'h2' and ('class', 'secret_flag') in attrs)
        for attr in attrs:
            if attr[0] == 'href' and attr[1][:10] == '/fakebook/':
                if not (HOST + attr[1]) in visited:
                    toVisit.append(attr[1])

    def handle_endtag(self, tag):
        return

    def handle_data(self, data):
        global secretFlags
        if secretFlagInData:
            secretFlags.append(data[6:])

def main():
    global visited
    global toVisit
    global visitSize
    headers = {}
    headers['Host'] = HOST
    httpRequest('GET', '/accounts/login/', headers, '')
    loginResponse = login()
    loginHeaders = resolveResponseHeaders(loginResponse)
    print "LOGIN: ", loginResponse
    toVisit.append(loginHeaders['Location'])
    parser = MyHTMLParser()
    while len(toVisit) > 0:
        visitSize+=1
        curPage = toVisit.pop(0)
        visited[curPage] = True
        response = httpRequest('GET', curPage, headers, '')
        try:
            firstTagIdx = response.index('<')
            htmlText = response[firstTagIdx:]
            parser.feed(htmlText)
        except Exception as e:
            pass
main()
for flag in secretFlags:
    print flag
s.close()
